package frc.robot.util;

import org.a05annex.util.geo3d.Line3d;
import org.a05annex.util.geo3d.Point3d;
import org.a05annex.util.geo3d.Vector3d;
import org.a05annex.util.geo3d.Xfm4x4d;
import org.a05annex.util.AngleD;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.HashMap;

// NOTE: it is expected that this class will move into either the a05annexUtil project or the a05annexRobot
// project. To accomplish this there must be no includes of any robot-specific classes like Constants.java,
// Robot.java, etc. if wpilib classes are included then this class can only be promoted to the a05annexRobot
// library
/**
 * A class representing the Limelight geometry and positioning of the limelight on the robot, and providing
 * telemetry for the limelight relative to the robot.
 */
public class LimelightTelemetry {

    /**
     * A class representing a limelight target on the field
     */
    public class Target {
        final String m_identifier;
        final Point3d m_centroid;
        final Vector3d m_normal;
        final double m_width;
        final double m_height;

        /**
         * Instantiate a target at the specified field position.
         *
         * @param identifier The identifier for the target
         * @param centroid The centroid of the target on the field.
         * @param normal The normal to the target with respect to the field.
         * @param width The width of the target.
         * @param height The height of the target.
         */
        public Target(@NotNull final String identifier, @NotNull final Point3d centroid, @NotNull final Vector3d normal,
               final double width, final double height) {
            m_identifier = identifier;
            m_centroid = centroid;
            m_normal = normal;
            m_width = width;
            m_height = height;
        }

        void printTarget() {
            System.out.printf("------ target '%s' ------%n", m_identifier);
            System.out.printf("  centroid: (%7.3f,%7.3f,%7.3f)%n",
                    m_centroid.getX(), m_centroid.getY(), m_centroid.getZ());
            System.out.printf("  normal:   (%7.3f,%7.3f,%7.3f)%n",
                    m_normal.getI(), m_normal.getJ(), m_normal.getK());
            System.out.printf("  width:    %7.3f%n", m_width);
            System.out.printf("  height:   %7.3f%n", m_height);
        }
    }

    /**
     * This is a class that represents the position of the target with respect to the robot. It is generated by
     * the {@link LimelightTelemetry} class and is a data structure only.
     */
    public class TargetPosition {
        final public String targetId;
        final public Vector3d robotToTarget;
        final public AngleD targetHeading;
        final public AngleD targetElevation;
        final public double targetDistance;
        final public Point3d limelightCenter;

        /**
         * @param targetId
         * @param robotToTarget
         * @param targetHeading
         * @param targetElevation
         * @param targetDistance
         * @param limelightCenter
         */
        TargetPosition(String targetId, Vector3d robotToTarget,
                       AngleD targetHeading, AngleD targetElevation,
                       double targetDistance, Point3d limelightCenter) {
            this.targetId = targetId;
            this.robotToTarget = robotToTarget;
            this.targetHeading = targetHeading;
            this.targetElevation = targetElevation;
            this.targetDistance = targetDistance;
            this.limelightCenter = limelightCenter;
        }

        public void printTargetPosition() {
            System.out.println(String.format("------ target position for '%s' ------", targetId));
            System.out.println(String.format(
                    "  robot to target:  (%7.3f,%7.3f,%7.3f)",
                    robotToTarget.getI(), robotToTarget.getJ(), robotToTarget.getK()));
            System.out.println(String.format(
                    "  target heading:    %7.3f", targetHeading.getDegrees()));
            System.out.println(String.format(
                    "  target elevation:  %7.3f", targetElevation.getDegrees()));
            System.out.println(String.format(
                    "  target_distance:   %7.3f", targetDistance));
        }
    }

    // The limelight coordinates
    static private final int CENTER = 0;
    static private final int UNIT_X = 1;
    static private final int UNIT_Y = 2;
    static private final int UNIT_Z = 3;

    static private final String[] LIMELIGHT_PT_NAMES = {"center:"};
    static private final String[] LIMELIGHT_V_NAMES = {"unit X:", "unit Y:", "unit Z:"};
    static private final Point3d[] LIMELIGHT_PT_GEOMETRY = {new Point3d(0.0, 0.0, 0.0)};
    static private final Vector3d[] LIMELIGHT_V_GEOMETRY = {new Vector3d(1.0, 0.0, 0.0),
            new Vector3d(0.0, 1.0, 0.0), new Vector3d(0.0, 0.0, 1.0)};

    private double m_robotX = 0.0;
    private double m_robotY = 0.0;
    private double m_robotZ = 0.0;
    private final AngleD m_heading = new AngleD(AngleD.RADIANS, 0.0);
    private final AngleD m_elevation = new AngleD(AngleD.RADIANS, 0.0);

    private final Xfm4x4d m_limelightToRobotXfm = new Xfm4x4d();
    private final Xfm4x4d m_robotToLimelightXfm = new Xfm4x4d();

    private final HashMap<String, Target> m_targets = new HashMap<>();


    /**
     * Instantiate a limelight geometry ay (0,0,0) 0.0,0.0.
     */
    public LimelightTelemetry() {
        setLimelightPosition(0.0, 0.0, 0.0,
                new AngleD(AngleD.DEGREES, 0.0), new AngleD(AngleD.DEGREES, 0.0));
    }

    /**
     * @param robotX    The X position of the limelight on the robot.
     * @param robotY    The Y position of the limelight on the robot.
     * @param robotZ    The Z position of the limelight on the robot.
     * @param heading   The heading of the limelight relative to the robot.
     * @param elevation The elevation of the limelight relative to the robot
     */
    public LimelightTelemetry(double robotX, double robotY, double robotZ, AngleD heading, AngleD elevation) {
        setLimelightPosition(robotX, robotY, robotZ, heading, elevation);
    }

    /**
     * Set the position of the limelight on the robot.
     *
     * @param robotX    The X position of the limelight on the robot.
     * @param robotY    The Y position of the limelight on the robot.
     * @param robotZ    The Z position of the limelight on the robot.
     * @param heading   The heading of the limelight relative to the robot.
     * @param elevation The elevation of the limelight relative to the robot
     */
    public void setLimelightPosition(double robotX, double robotY, double robotZ,
                                     AngleD heading, AngleD elevation) {
        m_robotX = robotX;
        m_robotY = robotY;
        m_robotZ = robotZ;
        m_heading.setValue(heading);
        m_elevation.setValue(elevation);
        // build the transform that positions the limelight relative to the robot
        // by initializing the transform to an identify, applying a scaling to map
        // from a left handed coordinate system to a right handed, a rotation to
        // set the elevation angle, and a translation to set position of the limelight
        // on the robot.
        m_limelightToRobotXfm.identity();
        // rescale the axis system from a left handed to right handed axis system
        m_limelightToRobotXfm.scale(1.0, 1.0, -1.0);
        // rotate around X until the Y is straight up (90deg) plus the tilt angle for the
        // camera facing forward
        AngleD xRotation = new AngleD(AngleD.DEGREES, 90.0).add(m_elevation);
        m_limelightToRobotXfm.rotate(Xfm4x4d.AXIS_X, xRotation);
        // The turntable rotation in robot Z
        m_limelightToRobotXfm.rotate(Xfm4x4d.AXIS_Z, new AngleD(heading).mult(-1.0));
        // And finally the translation that places the limelight on the robot.
        m_limelightToRobotXfm.translate(m_robotX, m_robotY, m_robotZ);
        // invert that to buld the transform that describes where the robot
        // elements are relative to the limelight
        m_limelightToRobotXfm.invert(m_robotToLimelightXfm);
    }

    /**
     * @return
     */
    public double getRobotX() {
        return m_robotX;
    }

    /**
     * @return
     */
    public double getRobotY() {
        return m_robotY;
    }

    /**
     * @return
     */
    public double getRobotZ() {
        return m_robotZ;
    }

    /**
     * @return
     */
    public Point3d getLocationOnRobot() {
        return new Point3d(m_robotX, m_robotY, m_robotZ);
    }

    /**
     * @return
     */
    AngleD getHeadingOnRobot() {
        return m_heading.cloneAngleD();
    }

    /**
     * @return
     */
    AngleD getElevationOnRobot() {
        return m_elevation.cloneAngleD();
    }

    /**
     * Add a target at the specified field position
     *
     * @param targetIdentifier
     * @param centroid
     * @param normal
     * @param width
     * @param height
     * @return
     */
    public int addTarget(String targetIdentifier, Point3d centroid, Vector3d normal,
                         double width, double height) {
        m_targets.put(targetIdentifier, new Target(targetIdentifier, centroid, normal, width, height));
        return m_targets.size() - 1;
    }

    /**
     *
     * @param targetIdentifier
     * @return
     */
    public Target getTarget(String targetIdentifier) {
        return m_targets.get(targetIdentifier);
    }

    /**
     * Transform a robot-relative point to limelight-relative
     * point. This takes a robot-relative point, and
     * creates a limelight-relative point. The robot-relative
     * point is unchanged.
     *
     * @param robotPt
     * @return
     */
    public Point3d xfmRobotPtToLimelight(Point3d robotPt) {
        return m_robotToLimelightXfm.transform(robotPt, new Point3d());
    }

    /**
     * Transform an array of robot-relative points to limelight-relative
     * points. This takes an array of robot-relative points, and
     * creates an array of limelight-relative points. The robot-relative
     * points are unchanged.
     *
     * @param robotPts
     * @return
     */
    public Point3d[] xfmRobotPtsToLimelight(Point3d[] robotPts) {
        return m_robotToLimelightXfm.cloneAndTransform(robotPts);
    }

    /**
     * Transform a robot-relative vector to limelight-relative
     * vector. This takes a robot-relative vector, and
     * creates a limelight-relative vector. The robot-relative
     * vector is unchanged.
     *
     * @param robotV
     * @return
     */
    public Vector3d xfmRobotVecToLimelight(Vector3d robotV) {
        return m_robotToLimelightXfm.transform(robotV, new Vector3d());
    }

    /**
     * Transform an array of robot-relative vectors to limelight-relative
     * vectors. This takes an array of robot-relative vectors, and
     * creates an array of limelight-relative vectors. The robot-relative
     * vectors are unchanged.
     *
     * @param robotVs
     * @return
     */
    public Vector3d[] xfmRobotVecsToLimelight(Vector3d[] robotVs) {
        return m_robotToLimelightXfm.cloneAndTransform(robotVs);
    }

    /**
     * Transform a limelight-relative point to robot-relative point and
     * return that robot-relative point. This is useful if you want to
     * display the limelight on a diagram of the robot.
     *
     * @param limelightPt
     * @return
     */
    public Point3d xfmLimelightPtToRobot(Point3d limelightPt) {
        return m_limelightToRobotXfm.transform(limelightPt, new Point3d());
    }

    /**
     * Transform the limelight-relative point geometry to robot-relative points
     * and return those robot-relative points. This is useful if you want to
     * display the limelight on a diagram of the robot.
     *
     * @return
     */
    public Point3d[] xfmLimelightPtGeoToRobot() {
        return m_limelightToRobotXfm.cloneAndTransform(LIMELIGHT_PT_GEOMETRY);
    }

    /**
     * Transform a limelight-relative vector to robot-relative vector and
     * return the robot-relative vector. This is useful if you want to
     * display the limelight on a diagram of the robot.
     *
     * @param limelightV
     * @return
     */
    public Vector3d xfmLimelightVecToRobot(Vector3d limelightV) {
        return m_limelightToRobotXfm.transform(limelightV, new Vector3d());
    }

    /**
     * Transform the limelight-relative vector geometry to robot-relative vectors
     * and returns those robot-relative vectors. This is useful if you want to
     * display the limelight on a diagram of the robot.
     *
     * @return
     */
    public Vector3d[] xfmLimelightVecGeoToRobot() {
        return m_limelightToRobotXfm.cloneAndTransform(LIMELIGHT_V_GEOMETRY);
    }

    /**
     * Print an annotated list of the limelight targets on the field. These Targets
     * are defined in field coordinates.
     */
    public void printLimelightTargets() {
        for (Target target : m_targets.values()) {
            target.printTarget();
        }
    }

    @NotNull
    public AngleD[] getLimelightAnglesToTarget(Point3d targetLocation) {
        AngleD[] targetAngles = {
                new AngleD().atan2(targetLocation.getX(), targetLocation.getZ()),
                new AngleD().atan2(targetLocation.getY(), targetLocation.getZ())};
        return targetAngles;
    }

    /**
     * This telemetry class does not monitor what the limelight sees, it simply uses the limelight
     * reported sightings to compute the target position with respect to the robot. This method
     * takes the target identifier for the target that is seen (other code identifies which is the
     * most likely target) and computes the relationship between the target and the robot.
     *
     * @param targetIdentifier
     * @param limelightX
     * @param limelightY
     */
    @Nullable
    public TargetPosition getTargetRelativeToRobot(@NotNull String targetIdentifier,
                                                   @NotNull AngleD limelightX, @NotNull AngleD limelightY) {
        Target target = m_targets.get(targetIdentifier);
        if (null == target) {
            // An invalid target identifier was found.
            return null;
        }
        Vector3d limelightToTarget = new Vector3d(limelightX.tan(), limelightY.tan(), 1.0).normalize();
        Vector3d robotToTarget = xfmLimelightVecToRobot(limelightToTarget);
        AngleD heading = new AngleD().atan2(robotToTarget.getI(), robotToTarget.getJ());
        AngleD elevation = new AngleD().asin(robotToTarget.getK());
        double targetDistance = (target.m_centroid.getZ() - m_robotZ) / elevation.sin();
        Vector3d targetToLimelight = robotToTarget.cloneVector3d().reverse();
        Point3d limelightCenter = new Line3d(target.m_centroid,
                targetToLimelight).pointAtDistance(targetDistance);

        return new TargetPosition(targetIdentifier, robotToTarget, heading, elevation,
                targetDistance, limelightCenter);
    }

}
